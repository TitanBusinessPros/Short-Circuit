<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Nexus - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a16;
            font-family: 'Orbitron', sans-serif;
            color: #00f3ff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            height: 80px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: rgba(10, 15, 30, 0.8);
            border-bottom: 1px solid rgba(0, 243, 255, 0.3);
            z-index: 10;
        }

        .game-title {
            font-size: 28px;
            text-shadow: 0 0 10px #00f3ff;
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 14px;
            color: #ff00ff;
        }

        .stats {
            display: flex;
            gap: 20px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            color: #ff00ff;
            font-size: 20px;
        }

        .stat-label {
            font-size: 12px;
            color: #00f3ff;
        }

        .game-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .footer {
            height: 100px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: rgba(10, 15, 30, 0.8);
            border-top: 1px solid rgba(0, 243, 255, 0.3);
            z-index: 10;
        }

        .energy-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 300px;
        }

        .energy-bar {
            width: 100%;
            height: 20px;
            background: rgba(10, 15, 30, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(0, 243, 255, 0.3);
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f3ff, #ff00ff);
            width: 100%;
            transition: width 0.3s;
        }

        .energy-label {
            font-size: 14px;
            color: #00f3ff;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .control-btn {
            background: rgba(20, 25, 45, 0.8);
            border: 1px solid rgba(0, 243, 255, 0.5);
            border-radius: 8px;
            width: 60px;
            height: 60px;
            color: #00f3ff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }

        .control-btn:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .keyboard-hint {
            font-size: 12px;
            color: rgba(0, 243, 255, 0.7);
            text-align: center;
            margin-top: 5px;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(10, 15, 40, 0.9) 0%, rgba(5, 10, 25, 0.95) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 15, 40, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 25;
        }

        .upgrade-container {
            background: rgba(20, 25, 45, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(0, 243, 255, 0.5);
            max-width: 600px;
            width: 90%;
        }

        .upgrade-title {
            color: #ff00ff;
            font-size: 32px;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff00ff;
        }

        .upgrade-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .upgrade-option {
            background: rgba(30, 35, 60, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }

        .upgrade-option:hover {
            background: rgba(40, 45, 80, 0.8);
            border-color: #ff00ff;
            transform: translateY(-5px);
        }

        .upgrade-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-option.disabled:hover {
            transform: none;
            border-color: rgba(0, 243, 255, 0.3);
            background: rgba(30, 35, 60, 0.8);
        }

        .upgrade-name {
            color: #00f3ff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .upgrade-desc {
            color: rgba(0, 243, 255, 0.8);
            font-size: 14px;
            margin-bottom: 15px;
        }

        .upgrade-cost {
            color: #ff00ff;
            font-size: 16px;
            text-align: right;
        }

        .upgrade-points {
            color: #00ff88;
            font-size: 24px;
            text-align: center;
            margin-bottom: 20px;
        }

        .btn {
            background: linear-gradient(45deg, #00f3ff, #ff00ff);
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            color: #0a0a16;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 25px rgba(0, 243, 255, 0.5);
            letter-spacing: 1px;
            display: block;
            margin: 0 auto;
        }

        .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 0, 255, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 5px 25px rgba(0, 243, 255, 0.5);
        }

        .instructions {
            background: rgba(20, 25, 45, 0.7);
            padding: 25px;
            border-radius: 12px;
            max-width: 600px;
            margin-top: 30px;
            line-height: 1.6;
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(5px);
            z-index: 21;
        }

        .instructions h3 {
            color: #ff00ff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 24px;
        }

        .instructions p {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .cyber-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: 1;
        }

        .mobile-controls {
            display: none;
        }

        @media (max-width: 768px) {
            .header {
                height: 60px;
                padding: 0 10px;
            }
            
            .game-title {
                font-size: 20px;
            }
            
            .game-subtitle {
                font-size: 12px;
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            .stat-label {
                font-size: 10px;
            }
            
            .footer {
                height: 80px;
                padding: 0 10px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .energy-container {
                width: 200px;
            }
            
            .keyboard-hint {
                display: none;
            }
            
            .upgrade-options {
                grid-template-columns: 1fr;
            }
            
            .upgrade-container {
                padding: 20px;
            }
            
            .mobile-controls {
                display: flex;
                position: absolute;
                bottom: 90px;
                left: 20px;
                gap: 10px;
                pointer-events: none;
            }
            
            .mobile-controls .control-btn {
                width: 50px;
                height: 50px;
            }
        }

        @media (max-width: 480px) {
            .header {
                flex-direction: column;
                height: 80px;
                padding: 5px;
            }
            
            .stats {
                gap: 10px;
            }
            
            .stat-value {
                font-size: 14px;
            }
            
            .footer {
                height: 70px;
            }
            
            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .energy-container {
                width: 150px;
            }
            
            .btn {
                padding: 15px 30px;
                font-size: 18px;
            }
            
            .instructions {
                padding: 15px;
                margin: 20px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div>
                <div class="game-title">NEURAL NEXUS</div>
                <div class="game-subtitle">Cybernetic Data Flow Interface</div>
            </div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="integrity">100%</div>
                    <div class="stat-label">INTEGRITY</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="processing">1.0</div>
                    <div class="stat-label">PROCESSING</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="firewalls">0</div>
                    <div class="stat-label">BREACHED</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="sector">01</div>
                    <div class="stat-label">SECTOR</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="upgradePoints">0</div>
                    <div class="stat-label">UPGRADE PTS</div>
                </div>
            </div>
        </div>
        
        <div class="game-area">
            <div class="cyber-grid"></div>
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <div class="footer">
            <div class="energy-container">
                <div class="energy-label">SYSTEM ENERGY</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="energyFill"></div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <button class="control-btn" id="upBtn">↑</button>
                </div>
                <div class="control-group">
                    <button class="control-btn" id="leftBtn">←</button>
                    <button class="control-btn" id="downBtn">↓</button>
                    <button class="control-btn" id="rightBtn">→</button>
                </div>
                <div class="keyboard-hint">or use arrow keys</div>
            </div>
        </div>
        
        <div class="start-screen" id="startScreen">
            <h2 style="font-size: 48px; margin-bottom: 10px; text-shadow: 0 0 20px #00f3ff;">NEURAL NEXUS</h2>
            <p style="font-size: 20px; margin-bottom: 30px; color: #ff00ff;">Cybernetic Data Flow Interface</p>
            <button class="btn" id="startBtn">INITIALIZE SYSTEM</button>
            
            <div class="instructions">
                <h3>DIRECTIVES</h3>
                <p>• Navigate the data streams using directional controls</p>
                <p>• Collect energy nodes (pink) to maintain system energy</p>
                <p>• Collect processing cores (gold) to earn upgrade points</p>
                <p>• Avoid firewall barriers and data corruption</p>
                <p>• Reach the central processing unit (green) in each sector</p>
                <p>• Use upgrade points to enhance your capabilities</p>
                <p style="text-align: center; margin-top: 15px; color: #00f3ff;">Use arrow keys or on-screen controls</p>
            </div>
        </div>
        
        <div class="upgrade-screen" id="upgradeScreen">
            <div class="upgrade-container">
                <h2 class="upgrade-title">NEURAL UPGRADES</h2>
                <div class="upgrade-points">UPGRADE POINTS: <span id="upgradePointsDisplay">0</span></div>
                
                <div class="upgrade-options">
                    <div class="upgrade-option" id="upgradeSpeed">
                        <div class="upgrade-name">PROCESSING SPEED</div>
                        <div class="upgrade-desc">Increase movement speed by 20%</div>
                        <div class="upgrade-cost">Cost: 3 points</div>
                    </div>
                    
                    <div class="upgrade-option" id="upgradeEnergy">
                        <div class="upgrade-name">ENERGY EFFICIENCY</div>
                        <div class="upgrade-desc">Reduce energy drain by 25%</div>
                        <div class="upgrade-cost">Cost: 4 points</div>
                    </div>
                    
                    <div class="upgrade-option" id="upgradeIntegrity">
                        <div class="upgrade-name">SYSTEM INTEGRITY</div>
                        <div class="upgrade-desc">Reduce firewall damage by 50%</div>
                        <div class="upgrade-cost">Cost: 5 points</div>
                    </div>
                    
                    <div class="upgrade-option" id="upgradeCollection">
                        <div class="upgrade-name">DATA COLLECTION</div>
                        <div class="upgrade-desc">Earn 2x upgrade points from cores</div>
                        <div class="upgrade-cost">Cost: 6 points</div>
                    </div>
                </div>
                
                <button class="btn" id="continueBtn">CONTINUE MISSION</button>
            </div>
        </div>
    </div>

    <script>
        // Game initialization
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to game area size
        function resizeCanvas() {
            const gameArea = document.querySelector('.game-area');
            canvas.width = gameArea.clientWidth;
            canvas.height = gameArea.clientHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameRunning = false;
        let dataIntegrity = 100;
        let processingPower = 1.0;
        let firewallsBreached = 0;
        let currentSector = 1;
        let energyLevel = 100;
        let upgradePoints = 0;

        // Player upgrades
        const upgrades = {
            speed: { level: 0, cost: 3, effect: 1.2 },
            energy: { level: 0, cost: 4, effect: 0.75 },
            integrity: { level: 0, cost: 5, effect: 0.5 },
            collection: { level: 0, cost: 6, effect: 2 }
        };

        // Player object
        const player = {
            x: 0,
            y: 0,
            radius: 0,
            color: '#00f3ff',
            baseSpeed: 0,
            speed: 0,
            trail: []
        };

        // Initialize player based on canvas size
        function initPlayer() {
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.radius = Math.min(canvas.width, canvas.height) * 0.02;
            player.baseSpeed = Math.min(canvas.width, canvas.height) * 0.005;
            player.speed = player.baseSpeed * (1 + upgrades.speed.level * 0.2);
            player.trail = [];
        }

        // Game objects
        let nodes = [];
        let dataStreams = [];
        let firewalls = [];
        let energyNodes = [];
        let processingCores = [];
        let particles = [];
        let targets = [];
        let restrictedZones = [];

        // Sector requirements
        const sectorRequirements = {
            1: { processing: 1.0, description: "Basic access" },
            2: { processing: 1.2, description: "Standard clearance" },
            3: { processing: 1.5, description: "Advanced protocols" },
            4: { processing: 2.0, description: "Expert systems" },
            5: { processing: 2.5, description: "Master control" }
        };

        // Initialize game objects
        function initializeGame() {
            nodes = [];
            dataStreams = [];
            firewalls = [];
            energyNodes = [];
            processingCores = [];
            particles = [];
            targets = [];
            restrictedZones = [];

            // Create neural nodes
            const nodeCount = 10 + currentSector * 2;
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    radius: 8 + Math.random() * 10,
                    pulse: 0
                });
            }

            // Create data streams between nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (Math.random() > 0.7) {
                        dataStreams.push({
                            from: nodes[i],
                            to: nodes[j],
                            pulse: 0
                        });
                    }
                }
            }

            // Create firewalls
            const firewallCount = 5 + currentSector;
            for (let i = 0; i < firewallCount; i++) {
                const size = Math.min(canvas.width, canvas.height) * (0.04 + currentSector * 0.01);
                firewalls.push({
                    x: Math.random() * (canvas.width - size * 2) + size,
                    y: Math.random() * (canvas.height - size * 2) + size,
                    width: size + Math.random() * size,
                    height: size + Math.random() * size,
                    rotation: Math.random() * Math.PI * 2,
                    pulse: 0,
                    speed: 0.5 + currentSector * 0.1
                });
            }

            // Create energy nodes
            const energyNodeCount = 8 + currentSector;
            for (let i = 0; i < energyNodeCount; i++) {
                energyNodes.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    radius: 8,
                    collected: false,
                    pulse: 0
                });
            }

            // Create processing cores
            const coreCount = 3 + Math.floor(currentSector / 2);
            for (let i = 0; i < coreCount; i++) {
                processingCores.push({
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: Math.random() * (canvas.height - 100) + 50,
                    radius: 10,
                    collected: false,
                    pulse: 0
                });
            }

            // Create targets
            targets.push({
                x: canvas.width - 100,
                y: canvas.height - 100,
                radius: 25,
                pulse: 0
            });

            // Create restricted zones for higher sectors
            if (currentSector >= 3) {
                const zoneCount = currentSector - 2;
                for (let i = 0; i < zoneCount; i++) {
                    restrictedZones.push({
                        x: Math.random() * (canvas.width - 200) + 100,
                        y: Math.random() * (canvas.height - 200) + 100,
                        radius: 80 + Math.random() * 50,
                        active: processingPower < sectorRequirements[currentSector].processing
                    });
                }
            }

            // Create initial particles
            const particleCount = Math.floor((canvas.width * canvas.height) / 1000);
            for (let i = 0; i < particleCount; i++) {
                createParticle();
            }
            
            // Initialize player
            initPlayer();
        }

        // Create a particle
        function createParticle() {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 3 + 1,
                speedX: (Math.random() - 0.5) * 2,
                speedY: (Math.random() - 0.5) * 2,
                life: Math.random() * 100 + 50,
                color: Math.random() > 0.5 ? '#00f3ff' : '#ff00ff'
            });
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;

                // Wrap around screen
                if (p.x < 0) p.x = canvas.width;
                if (p.x > canvas.width) p.x = 0;
                if (p.y < 0) p.y = canvas.height;
                if (p.y > canvas.height) p.y = 0;

                // Remove dead particles and create new ones
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    createParticle();
                }
            }
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 150;
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // Draw neural nodes with pulsing effect
        function drawNodes() {
            nodes.forEach(node => {
                node.pulse += 0.05;
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    node.x, node.y, 0,
                    node.x, node.y, node.radius
                );
                gradient.addColorStop(0, '#00f3ff');
                gradient.addColorStop(1, '#0066ff');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Pulsing glow effect
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius + Math.sin(node.pulse) * 5, 0, Math.PI * 2);
                ctx.strokeStyle = '#00f3ff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        // Draw data streams with flowing effect
        function drawDataStreams() {
            dataStreams.forEach(stream => {
                stream.pulse += 0.02;
                
                const dx = stream.to.x - stream.from.x;
                const dy = stream.to.y - stream.from.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                // Draw flowing data along the stream
                for (let i = 0; i < distance; i += 20) {
                    const progress = (i / distance + stream.pulse) % 1;
                    const x = stream.from.x + Math.cos(angle) * i;
                    const y = stream.from.y + Math.sin(angle) * i;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#00f3ff';
                    ctx.globalAlpha = 0.7 * (1 - progress);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                
                // Draw the stream line
                ctx.beginPath();
                ctx.moveTo(stream.from.x, stream.from.y);
                ctx.lineTo(stream.to.x, stream.to.y);
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // Draw firewalls with animated effect
        function drawFirewalls() {
            firewalls.forEach(firewall => {
                firewall.pulse += 0.03;
                
                // Move firewalls in higher sectors
                if (currentSector >= 2) {
                    firewall.x += Math.sin(firewall.pulse) * firewall.speed;
                    firewall.y += Math.cos(firewall.pulse) * firewall.speed;
                    
                    // Bounce off edges
                    if (firewall.x < 0 || firewall.x > canvas.width) firewall.speed *= -1;
                    if (firewall.y < 0 || firewall.y > canvas.height) firewall.speed *= -1;
                }
                
                ctx.save();
                ctx.translate(firewall.x + firewall.width / 2, firewall.y + firewall.height / 2);
                ctx.rotate(firewall.rotation);
                
                // Draw firewall rectangle
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(-firewall.width / 2, -firewall.height / 2, firewall.width, firewall.height);
                
                // Draw animated border
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-firewall.width / 2, -firewall.height / 2, firewall.width, firewall.height);
                
                // Draw pulsing inner lines
                const pulseSize = Math.sin(firewall.pulse) * 5;
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.lineWidth = 1;
                
                for (let i = 1; i < 4; i++) {
                    const offset = (firewall.width / 4) * i - firewall.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(offset - pulseSize, -firewall.height / 2);
                    ctx.lineTo(offset + pulseSize, firewall.height / 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        // Draw energy nodes
        function drawEnergyNodes() {
            energyNodes.forEach(node => {
                if (node.collected) return;
                
                node.pulse += 0.05;
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    node.x, node.y, 0,
                    node.x, node.y, node.radius
                );
                gradient.addColorStop(0, '#ff00ff');
                gradient.addColorStop(1, '#9900ff');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Pulsing effect
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius + Math.sin(node.pulse) * 3, 0, Math.PI * 2);
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        // Draw processing cores
        function drawProcessingCores() {
            processingCores.forEach(core => {
                if (core.collected) return;
                
                core.pulse += 0.05;
                
                ctx.beginPath();
                ctx.arc(core.x, core.y, core.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    core.x, core.y, 0,
                    core.x, core.y, core.radius
                );
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FF8C00');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Pulsing effect
                ctx.beginPath();
                ctx.arc(core.x, core.y, core.radius + Math.sin(core.pulse) * 4, 0, Math.PI * 2);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        // Draw restricted zones
        function drawRestrictedZones() {
            restrictedZones.forEach(zone => {
                if (!zone.active) return;
                
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fill();
                
                // Draw access denied text
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.font = '12px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('ACCESS DENIED', zone.x, zone.y - 10);
                ctx.fillText(`REQUIRED: ${sectorRequirements[currentSector].processing} PROCESSING`, zone.x, zone.y + 10);
            });
        }

        // Draw targets
        function drawTargets() {
            targets.forEach(target => {
                target.pulse += 0.05;
                
                ctx.beginPath();
                ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    target.x, target.y, 0,
                    target.x, target.y, target.radius
                );
                gradient.addColorStop(0, '#00ff88');
                gradient.addColorStop(1, '#009944');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Pulsing effect
                ctx.beginPath();
                ctx.arc(target.x, target.y, target.radius + Math.sin(target.pulse) * 8, 0, Math.PI * 2);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        // Draw player with trail effect
        function drawPlayer() {
            // Draw trail
            player.trail.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, player.radius * (index / player.trail.length), 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 243, 255, 0.2)';
                ctx.fill();
            });
            
            // Draw player
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            
            const gradient = ctx.createRadialGradient(
                player.x, player.y, 0,
                player.x, player.y, player.radius
            );
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#00f3ff');
            gradient.addColorStop(1, '#0066ff');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw glow
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7;
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Update trail
            player.trail.push({ x: player.x, y: player.y });
            if (player.trail.length > 10) {
                player.trail.shift();
            }
        }

        // Check collisions
        function checkCollisions() {
            // Check energy node collisions
            energyNodes.forEach(node => {
                if (!node.collected) {
                    const dx = player.x - node.x;
                    const dy = player.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.radius + node.radius) {
                        node.collected = true;
                        energyLevel = Math.min(100, energyLevel + 15);
                        updateUI();
                        
                        // Create collection effect
                        for (let i = 0; i < 10; i++) {
                            particles.push({
                                x: node.x,
                                y: node.y,
                                radius: Math.random() * 3 + 1,
                                speedX: (Math.random() - 0.5) * 5,
                                speedY: (Math.random() - 0.5) * 5,
                                life: 30,
                                color: '#ff00ff'
                            });
                        }
                    }
                }
            });
            
            // Check processing core collisions
            processingCores.forEach(core => {
                if (!core.collected) {
                    const dx = player.x - core.x;
                    const dy = player.y - core.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.radius + core.radius) {
                        core.collected = true;
                        const pointsEarned = upgrades.collection.level > 0 ? 2 : 1;
                        upgradePoints += pointsEarned;
                        updateUI();
                        
                        // Create collection effect
                        for (let i = 0; i < 15; i++) {
                            particles.push({
                                x: core.x,
                                y: core.y,
                                radius: Math.random() * 3 + 1,
                                speedX: (Math.random() - 0.5) * 5,
                                speedY: (Math.random() - 0.5) * 5,
                                life: 40,
                                color: '#FFD700'
                            });
                        }
                    }
                }
            });
            
            // Check restricted zone collisions
            restrictedZones.forEach(zone => {
                if (zone.active) {
                    const dx = player.x - zone.x;
                    const dy = player.y - zone.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.radius + zone.radius) {
                        // Push player out of restricted zone
                        const angle = Math.atan2(dy, dx);
                        player.x = zone.x + Math.cos(angle) * (zone.radius + player.radius);
                        player.y = zone.y + Math.sin(angle) * (zone.radius + player.radius);
                        
                        // Drain energy when touching restricted zone
                        energyLevel = Math.max(0, energyLevel - 1);
                        updateUI();
                    }
                }
            });
            
            // Check target collisions
            targets.forEach(target => {
                const dx = player.x - target.x;
                const dy = player.y - target.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.radius + target.radius) {
                    levelComplete();
                }
            });
            
            // Check firewall collisions
            firewalls.forEach(firewall => {
                const dx = player.x - (firewall.x + firewall.width / 2);
                const dy = player.y - (firewall.y + firewall.height / 2);
                
                // Simple rectangle collision (would need rotation consideration for accuracy)
                if (Math.abs(dx) < firewall.width / 2 + player.radius && 
                    Math.abs(dy) < firewall.height / 2 + player.radius) {
                    const damage = upgrades.integrity.level > 0 ? 0.25 : 0.5;
                    dataIntegrity = Math.max(0, dataIntegrity - damage);
                    energyLevel = Math.max(0, energyLevel - damage);
                    updateUI();
                }
            });
        }

        // Level complete
        function levelComplete() {
            firewallsBreached++;
            
            // Create celebration effect
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    radius: Math.random() * 4 + 2,
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    life: 60,
                    color: '#00ff88'
                });
            }
            
            // Check if we should show upgrade screen
            const coresCollected = processingCores.filter(core => core.collected).length;
            if (coresCollected > 0 || upgradePoints > 0) {
                showUpgradeScreen();
            } else {
                advanceToNextSector();
            }
        }

        // Show upgrade screen
        function showUpgradeScreen() {
            gameRunning = false;
            document.getElementById('upgradePointsDisplay').textContent = upgradePoints;
            updateUpgradeOptions();
            document.getElementById('upgradeScreen').style.display = 'flex';
        }

        // Update upgrade options based on available points
        function updateUpgradeOptions() {
            Object.keys(upgrades).forEach(upgradeId => {
                const upgrade = upgrades[upgradeId];
                const option = document.getElementById(`upgrade${upgradeId.charAt(0).toUpperCase() + upgradeId.slice(1)}`);
                
                if (upgradePoints >= upgrade.cost) {
                    option.classList.remove('disabled');
                } else {
                    option.classList.add('disabled');
                }
            });
        }

        // Advance to next sector
        function advanceToNextSector() {
            currentSector++;
            
            // Check if player has required processing power for next sector
            if (sectorRequirements[currentSector] && processingPower < sectorRequirements[currentSector].processing) {
                alert(`ACCESS DENIED: Sector ${currentSector} requires ${sectorRequirements[currentSector].processing} processing power!`);
                currentSector--; // Stay in current sector
            }
            
            // Reset player position
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.trail = [];
            
            // Reinitialize game with new level
            setTimeout(() => {
                initializeGame();
                updateUI();
                gameRunning = true;
                gameLoop();
            }, 500);
        }

        // Update UI
        function updateUI() {
            document.getElementById('integrity').textContent = Math.round(dataIntegrity) + '%';
            document.getElementById('processing').textContent = processingPower.toFixed(1);
            document.getElementById('firewalls').textContent = firewallsBreached;
            document.getElementById('sector').textContent = currentSector.toString().padStart(2, '0');
            document.getElementById('upgradePoints').textContent = upgradePoints;
            document.getElementById('energyFill').style.width = energyLevel + '%';
        }

        // Game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            // Clear canvas with fade effect
            ctx.fillStyle = 'rgba(10, 10, 22, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw game elements
            updateParticles();
            drawParticles();
            drawDataStreams();
            drawNodes();
            drawFirewalls();
            drawEnergyNodes();
            drawProcessingCores();
            drawRestrictedZones();
            drawTargets();
            drawPlayer();
            
            // Check collisions
            checkCollisions();
            
            // Gradually decrease energy (adjusted by energy efficiency upgrade)
            const energyDrain = upgrades.energy.level > 0 ? 0.0375 : 0.05;
            energyLevel = Math.max(0, energyLevel - energyDrain);
            updateUI();
            
            // Check for game over
            if (energyLevel <= 0) {
                gameOver();
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Game over function
        function gameOver() {
            gameRunning = false;
            alert('System Failure: Energy depleted. Rebooting...');
            resetGame();
        }

        // Reset game
        function resetGame() {
            dataIntegrity = 100;
            processingPower = 1.0;
            firewallsBreached = 0;
            currentSector = 1;
            energyLevel = 100;
            upgradePoints = 0;
            
            // Reset upgrades
            Object.keys(upgrades).forEach(key => {
                upgrades[key].level = 0;
            });
            
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.trail = [];
            
            initializeGame();
            updateUI();
            
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('upgradeScreen').style.display = 'none';
        }

        // Start game
        function startGame() {
            gameRunning = true;
            document.getElementById('startScreen').style.display = 'none';
            gameLoop();
        }

        // Initialize game
        initializeGame();
        updateUI();

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('continueBtn').addEventListener('click', () => {
            document.getElementById('upgradeScreen').style.display = 'none';
            advanceToNextSector();
        });
        
        // Upgrade event listeners
        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (upgradePoints >= upgrades.speed.cost) {
                upgradePoints -= upgrades.speed.cost;
                upgrades.speed.level++;
                processingPower += 0.2;
                player.speed = player.baseSpeed * (1 + upgrades.speed.level * 0.2);
                updateUI();
                updateUpgradeOptions();
            }
        });
        
        document.getElementById('upgradeEnergy').addEventListener('click', () => {
            if (upgradePoints >= upgrades.energy.cost) {
                upgradePoints -= upgrades.energy.cost;
                upgrades.energy.level++;
                updateUI();
                updateUpgradeOptions();
            }
        });
        
        document.getElementById('upgradeIntegrity').addEventListener('click', () => {
            if (upgradePoints >= upgrades.integrity.cost) {
                upgradePoints -= upgrades.integrity.cost;
                upgrades.integrity.level++;
                updateUI();
                updateUpgradeOptions();
            }
        });
        
        document.getElementById('upgradeCollection').addEventListener('click', () => {
            if (upgradePoints >= upgrades.collection.cost) {
                upgradePoints -= upgrades.collection.cost;
                upgrades.collection.level++;
                updateUI();
                updateUpgradeOptions();
            }
        });
        
        // Movement controls
        const upBtn = document.getElementById('upBtn');
        const downBtn = document.getElementById('downBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        
        let keys = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        
        // Reset keys when window loses focus to prevent stuck keys
        window.addEventListener('blur', () => {
            keys.up = false;
            keys.down = false;
            keys.left = false;
            keys.right = false;
        });
        
        // Desktop controls
        upBtn.addEventListener('mousedown', () => keys.up = true);
        upBtn.addEventListener('mouseup', () => keys.up = false);
        upBtn.addEventListener('mouseleave', () => keys.up = false);
        
        downBtn.addEventListener('mousedown', () => keys.down = true);
        downBtn.addEventListener('mouseup', () => keys.down = false);
        downBtn.addEventListener('mouseleave', () => keys.down = false);
        
        leftBtn.addEventListener('mousedown', () => keys.left = true);
        leftBtn.addEventListener('mouseup', () => keys.left = false);
        leftBtn.addEventListener('mouseleave', () => keys.left = false);
        
        rightBtn.addEventListener('mousedown', () => keys.right = true);
        rightBtn.addEventListener('mouseup', () => keys.right = false);
        rightBtn.addEventListener('mouseleave', () => keys.right = false);
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = true;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.down = false;
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
        });
        
        // Movement update
        function updatePlayerPosition() {
            if (keys.up) player.y -= player.speed;
            if (keys.down) player.y += player.speed;
            if (keys.left) player.x -= player.speed;
            if (keys.right) player.x += player.speed;
            
            // Keep player within bounds
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        }
        
        // Update player position in game loop
        const originalGameLoop = gameLoop;
        gameLoop = function() {
            updatePlayerPosition();
            originalGameLoop();
        };
    </script>
</body>
</html>